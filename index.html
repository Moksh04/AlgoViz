<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algortithm Visualizer</title>
    <link rel="stylesheet" href="mainStyles.css" />
    <script src="minified/gsap.min.js"></script>
    <script src="particles.js" defer></script>
    <script src="particleTxt.js" defer></script>
</head>

<body>
    <canvas class="canvas1"></canvas>
    <canvas class="canvas2"></canvas>
    <button class="selectBtn" onclick="openNav()"></button>
    <div class="selMenu">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <h1>Logarithmic</h1>
        <a href="./Sorts/Merge Sort/merge.html">Merge Sort</a>
        <a href="./Sorts/Quick Sort/quick.html">Quick Sort</a>
        <a href="./Sorts/Heap Sort/heap.html">Heap Sort</a>
        <h1>Quadratic</h1>
        <a href="./Sorts/Insertion Sort/insertion.html">Insertion Sort</a>
        <a href="./Sorts/Bubble Sort/bubble.html">Bubble Sort</a>
        <h1>Linear</h1>
        <a href="./Sorts/Counting Sort/counting.html">Counting Sort</a>
        <h1>Maze Generator</h1>
        <a href="./Maze Generator/index.html">Recursive Backtracker</a>
        <h1>Path finding</h1>
        <a href="./A star search/index.html">A* Search</a>
    </div>
    <div class="hero">
        <div class="heroText">
            <span id="sp1">ALGO</span>
            <span id="sp2">VIZ</span>
        </div>
    </div>
    <!-- <div class="container "> -->
    <div class="container open">
        <div class="sorts">
            <h1 onclick="openNav()">Sorting Algorithms</h1>
            Sorting algorithms are used to sort a data structure according to a specific order relationship, such as
            numerical order or lexicographical order.
            <br><br>
            This operation is one of the most important and widespread in computer science. For a long time, new methods
            have been developed to make this procedure faster and faster.
            <br><br>
            There are currently hundreds of different sorting algorithms, each with its own specific characteristics.
            They are classified according to two metrics: space complexity and time complexity.
            <br><br>
            Those two kinds of complexity are represented with asymptotic notations, mainly with the symbols O, Θ, Ω,
            representing respectively the upper bound, the tight bound, and the lower bound of the algorithm's
            complexity, specifying in brackets an expression in terms of n, the number of the elements of the data
            structure.
            <br><br>
            Most of them fall into two categories:
            <br><br>
            <span>Logarithmic</span>
            <br>
            The complexity is proportional to the binary logarithm (i.e to the base 2) of n.
            An example of a logarithmic sorting algorithm is Quick sort, with space and time complexity O(n × log n).
            <br><br>
            <span>Quadratic</span>
            <br>
            The complexity is proportional to the square of n.
            An example of a quadratic sorting algorithm is Bubble sort, with a time complexity of O(n2).
            Space and time complexity can also be further subdivided into 3 different cases: best case, average case and
            worst case.
            <br><br>
            Sorting algorithms can be difficult to understand and it's easy to get confused. We believe visualizing
            sorting algorithms can be a great way to better understand their functioning while having fun!
        </div>
        <div class="mazeGen">
            <h1 onclick="openNav()">Maze Generator</h1>
            A maze can be generated by starting with a predetermined arrangement of cells (most commonly a rectangular
            grid but other arrangements are possible) with wall sites between them. This predetermined arrangement can
            be considered as a connected graph with the edges representing possible wall sites and the nodes
            representing cells. The purpose of the maze generation algorithm can then be considered to be making a
            subgraph in which it is challenging to find a route between two particular nodes.
            <br><br>

        </div>
    </div>
    <div class="footer">
        <h1>ALGORITHM VISUALIZER</h1>
        <pre>by</pre>
        <p>Brij Mohan</p>
    </div>
</body>

</html>